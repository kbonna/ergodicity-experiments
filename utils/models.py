import random
import numpy as np
from functools import total_ordering

class IsoelasticBoundError(ValueError):
    """Raised when utility or inverse utility cannot be computed for specific 
    value."""

class DynamicMismatchError(ValueError):
    """Raised if two entities correspond to different dynamics and cannot be
    used together."""

def isoelastic_utility(x, eta):
    """Isoelastic utility for a given wealth.
    
    Args:
        x (float): Current wealth.
        eta (float): Risk-aversion parameter.
        
    Notes:
        Functions is well defined only for positive wealth.
    """
    if np.any(x <= 0):
        msg = "isoelastic utility is only defined for positive wealth"
        raise IsoelasticBoundError(msg)
    if np.isclose(eta, 1):
        return np.log(x)
    else:
        return (np.power(x, 1-eta) - 1) / (1 - eta)
    
def inverse_isoelastic_utility(u, eta):
    """Inverse isoelastic utility function mapping from utility to wealth.
    
    Args:
        u (float): Current utility.
        eta (float): Risk-aversion parameter.
        
    Notes: 
        Function is invertible for a specific range of real values. It comes
        from the fact that u(x) is bounded. The bound is (-1) / (1 - eta) for 
        both eta > 1 and eta < 1. For eta's greater than one the bound is 
        upper-bound, whereas for eta's less than one the bound is lower-boud.
    """
    if not np.isclose(eta, 1):
        bound = (-1) / (1 - eta)
        if eta > 1 and np.any(u >= bound) or eta < 1 and np.any(u <= bound):
            raise IsoelasticBoundError("isoelastic utility bound exceeded")
        return np.power(u * (1 - eta) + 1, 1 / (1-eta))
    return np.exp(u)

@total_ordering
class IsoelasticWealthChange:
    """Deterministic wealth change for isoelastic utility function.
    
    Represents deterministic wealth change for a given dynamic. It realizes 
    an update equation: 
    
    x(t+Δt) = w(u(x(t)) + ɣΔt),
    
    where u is the isoelastic utility function, w is the inverse of u, and ɣ is 
    the utility growth rate. It covers broad range of different dynamics. For 
    example is includes additive dynamic (eta=0), multiplicative dynamic 
    (eta=1), and square-root dynamic (eta=0.5).

    Attributes:
        gamma (float):
            Growth rate.
        eta (float): 
            Wealth change dynamic parameter. Corresponds to risk aversion 
            parameter in time-optimal utility function for dynamic generated by 
            the wealth change.
        is_null (bool):
            Determines if gamble does not affect wealth (is null gamble).
        is_win (bool):
            Determines if gamble increases wealth.
        is_loss (bool):
            Determines if gamble decreases wealth.
    """    
    def __init__(self, gamma, eta=0):
        self._gamma = gamma
        self._eta = eta
    
    @property
    def gamma(self):
        return self._gamma
    
    @property
    def eta(self):
        return self._eta
    
    @property
    def is_null(self):
        return self.gamma == 0
    
    @property
    def is_win(self):
        return self.gamma > 0
    
    @property
    def is_loss(self):
        return self.gamma < 0
    
    def __str__(self):
        return  f"{self.gamma:+.2f} [eta={self.eta}]"
        
    def __repr__(self):
        return self.__str__()
    
#     def __call__(self, x, delta_t=1):
#         return inverse_isoelastic_utility(
#             isoelastic_utility(x, self.eta) + self.gamma * delta_t, 
#             self.eta
#         )
    def __call__(self, x, delta_t=1):
        try:
            return inverse_isoelastic_utility(
                isoelastic_utility(x, self.eta) + self.gamma * delta_t, 
                self.eta
            )
        except IsoelasticBoundError:
            return 0
        
    def __eq__(self, other):
        return self.gamma == other.gamma and self.eta == other.eta
    
    def __lt__(self, other):
        if self.eta != other.eta:
            raise DynamicMismatchError("cannot compare different dynamics")
        return self.gamma < other.gamma
        
    def evolve_wealth(self, x0, n_steps):
        """Apply wealth change multiple times to evolve initial wealth.
        
        Args:
            x0 (float):
                Initial agent's wealth.
            n_steps (int):
                Number of time steps for wealth evolution.
    
        Returns:
            Vector of wealth dynamics starting from inital wealth.
        """
        x = np.zeros(n_steps)
        x[0] = x0
        for i in range(1, n_steps):
            try:
                x[i] = self(x[i - 1])
            except IsoelasticBoundError:
                x[i] = x[i - 1]
        return x

class Gamble:
    """Pair of deterministic wealth changes with probabilities. 
    
    Represents a gamble offered to an agent. A gamble is composed of two 
    deterministic wealth changes, experimentally represented as fractals, with
    specified probabilities of being chosen to affect wealth. Usually these
    probabilities are equal.
    
    Note:
        Gamble should be composed of two wealth changes with the same dynamic. 
        For now only IsoelasticWealthChange is accepted, this can be modified 
        later.
        
    Attributes:
        p (list-like):
            Wealth changes probabilities. Fifty-fifty by default.
        wc1 (IsoelasticWealthChange):
            First deterministic wealth change.
        wc2 (IsoelasticWealthChange):
            Second deterministic wealth change.
        eta (float): 
            Gamble dynamic parameter. Corresponds to time-optimal utility 
            function for dynamic generated by gamble.
        gamma_avg (float):
            Expected gamble growth rate.
        is_win (bool):
            Determines if gamble is composed of win wealth changes.
        is_loss (bool):
            Determines if gamble is composed of loss wealth changes.
        is_win_and_null (bool):
            Determines if gamble is composed of win and null wealth changes.
        is_loss_and_null (bool):
            Determines if gamble is composed of loss and null wealth changes.
        is_win_or_null (bool):
            Determines if gamble is composed of two win or win and null wealth 
            changes.
        is_loss_or_null (bool):
            Determines if gamble is composed of two loss or loss and null wealth 
            changes.
        is_mixed (bool):
            Determines if gamble is composed of win and loss wealth changes.
        is_null (bool):
            Determines if gamble is composed of null wealth changes.
    """
    def __init__(self, wc1, wc2, p=(0.5, 0.5)):
        if (not isinstance(wc1, IsoelasticWealthChange) or 
            not isinstance(wc2, IsoelasticWealthChange)):
            msg = "wc1 and wc2 have to be IsoelasticWealthChange" + \
                  f" but are {type(wc1)} and {type(wc2)}"
            raise TypeError(msg)
        if wc1.eta != wc2.eta: 
            msg = "both wealth changes should resemble same dynamic"
            raise DynamicMismatchError(msg)
        self._wealth_changes = (wc1, wc2)
        self._p = p
        
        # average growth rate
        self._gamma_avg = p[0] * wc1.gamma + p[1] * wc2.gamma
    
    @property
    def eta(self):
        return self.wc1.eta
    
    @property
    def gamma_avg(self):
        return self._gamma_avg
    
    @property
    def max_gamma(self):
        return np.max((self.wc1.gamma, self.wc2.gamma))
    
    @property 
    def p(self):
        return self._p
    
    @property
    def wc1(self):
        return self._wealth_changes[0]

    @property
    def wc2(self):
        return self._wealth_changes[1]
    
    @property
    def is_win(self):
        return self.wc1.is_win and self.wc2.is_win 
    
    @property
    def is_loss(self):
        return self.wc1.is_loss and self.wc2.is_loss 

    @property
    def is_win_and_null(self):
        return ((self.wc1.is_null and self.wc2.is_win) or 
                (self.wc1.is_win and self.wc2.is_null)) 
    
    @property
    def is_loss_and_null(self):
        return ((self.wc1.is_null and self.wc2.is_loss) or 
                (self.wc1.is_loss and self.wc2.is_null))
    
    @property
    def is_win_or_null(self):
        return self.is_win_and_null or self.is_win
    
    @property
    def is_loss_or_null(self):
        return self.is_loss_or_null or self.is_loss
    
    @property
    def is_mixed(self):
        return ((self.wc1.is_win and self.wc2.is_loss) or 
                (self.wc1.is_loss and self.wc2.is_win))
    
    @property
    def is_null(self):
        return self.wc1.is_null and self.wc2.is_null
    
    def __call__(self, x):
        """Realize gamble by probabilistically applying one of wealth changes.
        
        Args:
            x (float):
                Current agent's wealth.
                
        Returns:
            Wealth in the next time step.      
        """
        return np.random.choice(self._wealth_changes, p=self._p)(x)
    
    def __str__(self):
        return f"({self.wc1.gamma:+.2f}, {self.wc2.gamma:+.2f}) [eta={self.wc1.eta}]"
    
    def __repr__(self):
        return self.__str__()
    
    def __eq__(self, other):
        if self.eta != other.eta:
            return False
        return ((self.wc1 == other.wc1 and self.wc2 == other.wc2) or 
                (self.wc1 == other.wc2 and self.wc2 == other.wc1))
        
    def __lt__(self, other):
        if self.eta != other.eta:
            raise DynamicMismatchError("cannot compare different dynamics")
        return self.gamma_avg < other.gamma_avg
    
    def evolve_wealth(self, x0, n_steps):
        """Apply gamble multiple times to evolve initial wealth.
        
        Args:
            x0 (float):
                Initial agent's wealth.
            n_steps (int):
                Number of time steps for wealth evolution.
    
        Returns:
            Vector of wealth dynamics starting from inital wealth.
        """
        x = np.zeros(n_steps)
        x[0] = x0
        for i in range(1, n_steps):
            x[i] = self(x[i - 1])
        return x

class GamblePair:
    """Pair of gambles representing single experimental trial.
    
    Basic building block of experiment consising of two gamble pairs which an
    agent can choose between. 
    
    Note:
        Gamble pair should be composed of two gambles with the same dynamic. It 
        means that all four wealth changes should have the same eta.
        
    Attributes:
        g1 (Gamble):
            Left-hand side gamble.
        g2 (Gamble):
            Right-hand side gamble.
        gamma_distance (float):
            Absolute value of the difference in average growth rates between 
            gambles. The more distance between gambles the easier the choice 
            between them.
        is_nobrainer (bool):
            Determines if two gambles share the same wealth change.
        is_mixed (bool):
            Determines if both gambles are mixed.
        is_win (bool):
            Determines if gambles are win-only.
        is_loss (bool): 
            Determines if gambles are loss-only. 
    """
    def __init__(self, g1, g2):
        if not isinstance(g1, Gamble) or not isinstance(g2, Gamble):
            msg = f"g1 and g2 have to be Gamble but are {type(g1)} and {type(g2)}"
            raise TypeError(msg)
        if g1.eta != g2.eta:
            msg = "both gambles should resemble same dynamic"
            raise DynamicMismatchError(msg)
        self._g1 = g1
        self._g2 = g2

        # Difference in average growth rate 
        self._gamma_distance = abs(g1.gamma_avg - g2.gamma_avg)

    @property
    def g1(self):
        return self._g1
    
    @property
    def g2(self):
        return self._g2
    
    @property
    def gamma_distance(self):
        return self._gamma_distance
    
    @property
    def is_mixed(self):
        return self.g1.is_mixed and self.g2.is_mixed
    
    @property
    def is_win(self):
        return self.g1.is_win and self.g2.is_win

    @property
    def is_loss(self):
        return self.g1.is_loss and self.g2.is_loss
    
    @property
    def is_nobrainer(self):
        return (self.g1.wc1 == self.g2.wc1 or 
                self.g1.wc1 == self.g2.wc2 or 
                self.g1.wc2 == self.g2.wc1 or 
                self.g1.wc2 == self.g2.wc2) 
    
    def __str__(self):
        wc11, wc12 = self.g1.wc1, self.g1.wc2
        wc21, wc22 = self.g2.wc1, self.g2.wc2
        return f"({wc11.gamma:+.2f}, {wc12.gamma:+.2f})" + " : "  + \
               f"({wc21.gamma:+.2f}, {wc22.gamma:+.2f}) [eta={wc11.eta}]"
    
    def __repr__(self):
        return self.__str__()
        
class Experiment:
    
    def __init__(self, trials):
        if not all(isinstance(item, GamblePair) for item in trials):
            raise TypeError("all trials should be instances of GamblePair")
        self._trials = trials
        
    @property
    def trials(self):
        return self._trials
        
    def shuffle_trials(self):
        random.shuffle(self._trials)
        
    def __len__(self):
        return len(self.trials)
        
class IsoelasticAgent:
    """Represent an agent using isoelastic utility function to make choices.
    
    Instances is the model of subject or algorithm that has numerical wealth
    and chooses between different gamble pairs to evolve their wealth. Each
    agent is equipped with their own isoelastic utility function with fixed risk
    aversion parameter. Utility function is used to calculate expected change
    in utility for gambles and act accordingly to this quantity. 
    
    Attributes:
        eta (float):
            Risk aversion parameter for isoelastic utility function.
        wealth (float):
            Current wealth of an agent.
        initial_wealth (float):
            Wealth that was used to create an agent instance.
        current_utility (float):
            Utility value for current wealth.
    """
    
    def __init__(self, eta, wealth=0):
        self._eta = eta
        self._wealth = float(wealth)
        self._initial_wealth = float(wealth)
        
        # agent's utility function with fixed risk aversion
        self.utility = lambda x: isoelastic_utility(x, eta)
        
    @property
    def eta(self):
        return self._eta
        
    @property
    def wealth(self):
        return self._wealth
    
    @property
    def initial_wealth(self):
        return self._initial_wealth
    
    @property
    def current_utility(self):
        return self.utility(self.wealth)
    
    def reset_wealth(self):
        """Restore wealth to its initial value."""
        self._wealth = self._initial_wealth
        
    def gamble_utility_after(self, g):
        """Utility after applying wealth changes from a specific gamble.
        
        Args:
            g (Gamble):
                Gamble instance.
        
        Returns:
            Tuple representing utility after applying wealth changes from the 
            gamble g.
        """
        return tuple(self.utility(wc(self.wealth)) for wc in (g.wc1, g.wc2))
    
    def gamble_utility_change(self, g):
        """Utility change after applying wealth changes from a specific gamble. 
        
        Args: 
            g (Gamble):
                Gamble instance.
                
        Returns:
            Tuple representing utility change after applying wealth changes from
            the gamble g. Utility change Δu is the difference between utility 
            after applying gamble's wealth changes and utility of current 
            wealth. If return value is positive, expected change in utility 
            gamble should increase utility in the long run, otherwise it should
            decrease utility over time.
        """
        u = self.gamble_utility_after(g)
        return tuple(ut - self.current_utility for ut in u)
    
    def gamble_expected_utility_change(self, g):
        """Expected utility change for the gamble.
        
        Args:
            g (Gamble):
                Gamble instance.
                
        Returns:
            Single scalar value representing expected change in utility for a 
            given value.
        """
        du = self.gamble_utility_change(g)
        edu = du[0] * g.p[0] + du[1] * g.p[1] 
        return 0 if np.isclose(edu, 0) else edu 
    
    def gamble_difference(self, g1, g2):
        """Difference in expected utility change between two gambles.
        
        Args:
            g1 (Gamble):
                First gamble instance.
            g2 (Gamble):
                Second gamble instance.
        
        Returns:
            Number representing the difference between expected change in 
            utility for the first and second gamble. If the return value is 
            greater then 0, g1 should be preferred over g2, otherwise g2 should
            be preferred over g1.
        """
        return (self.gamble_expected_utility_change(g1) - 
                self.gamble_expected_utility_change(g2))
    
    def deterministic_choice(self, g1, g2):
        """Make deterministic choice between the pair of gambles.
        
        Args:
            g1 (Gamble):
                First gamble instance.
            g2 (Gamble):
                Second gamble instance.
                
        Returns:
            Chosen gamble instance.
        """
        if self.gamble_difference(g1, g2) >= 0:
            return g1
        else:
            return g2
        
    def stochastic_choice(self, g1, g2):
        pass
        
    def apply_gamble(self, g):
        """Use gamble to evolve wealth in a single time step.
        
        Args:
            g (Gamble):
                Gamble instance:
                
        Returns:
            None.
        """
        self._wealth = g(self._wealth)
        
    def run_experiment(self, experiment):
        x = np.zeros(len(experiment) + 1)
        x[0] = self.wealth
        for t, trial in enumerate(experiment.trials):
            try:
                g = self.deterministic_choice(trial.g1, trial.g2)
                self.apply_gamble(g)
                x[t + 1] = self.wealth
            except IsoelasticBoundError:
                x[t + 1] = 0
        return x
    
    def __str__(self):
        return f"IsoelasticAgent(eta={self.eta}, wealth={self.wealth})" 
    
    def __repr__(self):
        return self.__str__()
